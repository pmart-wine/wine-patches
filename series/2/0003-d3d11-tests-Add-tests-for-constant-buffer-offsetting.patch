From 072a2c4484fe277769cff68aa58ac966fe02ada9 Mon Sep 17 00:00:00 2001
From: Pablo Martin <pmartXXXXXXXX>
Date: Mon, 28 May 2018 04:20:50 +0200
Subject: [PATCH 3/5] d3d11/tests: Add tests for constant buffer offsetting.

Signed-off-by: Pablo Martin <pmartXXXXXXXX>
---
 dlls/d3d11/tests/d3d11.c | 322 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 322 insertions(+)

diff --git a/dlls/d3d11/tests/d3d11.c b/dlls/d3d11/tests/d3d11.c
index f6f4fe3a55..d43a1b1248 100644
--- a/dlls/d3d11/tests/d3d11.c
+++ b/dlls/d3d11/tests/d3d11.c
@@ -11262,6 +11262,327 @@ static void test_fragment_coords(void)
     release_test_context(&test_context);
 }
 
+static void test_buffer_offset(void)
+{
+    struct d3d11_test_context test_context;
+    ID3D11PixelShader *ps;
+    ID3D11DeviceContext *context;
+    ID3D11DeviceContext1 *context1;
+    ID3D11Device *device;
+    ID3D11Buffer *ps_cb, *ps_cb_result = NULL;
+    DWORD color;
+    HRESULT hr;
+
+    static const DWORD ps_code[] =
+    {
+#if 0
+        float2 cutoff;
+
+        float4 main(float4 position : SV_POSITION) : SV_TARGET
+        {
+            float4 ret = float4(0.0, 0.0, 0.0, 1.0);
+
+            if (position.x > cutoff.x)
+                ret.y = 1.0;
+            if (position.y > cutoff.y)
+                ret.z = 1.0;
+
+            return ret;
+        }
+#endif
+        0x43425844, 0x49fc9e51, 0x8068867d, 0xf20cfa39, 0xb8099e6b, 0x00000001, 0x00000144, 0x00000003,
+        0x0000002c, 0x00000060, 0x00000094, 0x4e475349, 0x0000002c, 0x00000001, 0x00000008, 0x00000020,
+        0x00000000, 0x00000001, 0x00000003, 0x00000000, 0x0000030f, 0x505f5653, 0x5449534f, 0x004e4f49,
+        0x4e47534f, 0x0000002c, 0x00000001, 0x00000008, 0x00000020, 0x00000000, 0x00000000, 0x00000003,
+        0x00000000, 0x0000000f, 0x545f5653, 0x45475241, 0xabab0054, 0x52444853, 0x000000a8, 0x00000040,
+        0x0000002a, 0x04000059, 0x00208e46, 0x00000000, 0x00000001, 0x04002064, 0x00101032, 0x00000000,
+        0x00000001, 0x03000065, 0x001020f2, 0x00000000, 0x02000068, 0x00000001, 0x08000031, 0x00100032,
+        0x00000000, 0x00208046, 0x00000000, 0x00000000, 0x00101046, 0x00000000, 0x0a000001, 0x00102062,
+        0x00000000, 0x00100106, 0x00000000, 0x00004002, 0x00000000, 0x3f800000, 0x3f800000, 0x00000000,
+        0x08000036, 0x00102092, 0x00000000, 0x00004002, 0x00000000, 0x00000000, 0x00000000, 0x3f800000,
+        0x0100003e,
+    };
+    static const float red[] = {1.0f, 0.0f, 0.0f, 0.5f};
+    unsigned int offset[] = {16};
+    unsigned int size[] = {16};
+    unsigned int offset_result = 0;
+    unsigned int size_result = 0;
+
+    struct vec4 cutoff[48];
+    memset(cutoff, 0, sizeof(cutoff));
+    cutoff[16].x = 320.0f;
+    cutoff[16].y = 240.0f;
+    cutoff[32].x = 16.0f;
+    cutoff[32].y = 16.0f;
+
+    if (!init_test_context(&test_context, NULL))
+        return;
+
+    device = test_context.device;
+    context = test_context.immediate_context;
+
+    hr = ID3D11DeviceContext_QueryInterface(context, &IID_ID3D11DeviceContext1, (void **)&context1);
+    ok(SUCCEEDED(hr) || broken(hr == E_NOINTERFACE) /* Not available on all Windows versions. */,
+            "Failed to query ID3D11DeviceContext1, hr %#x.\n", hr);
+
+    if (!SUCCEEDED(hr))
+    {
+        release_test_context(&test_context);
+        return;
+    }
+
+    hr = ID3D11Device_CreatePixelShader(device, ps_code, sizeof(ps_code), NULL, &ps);
+    ok(SUCCEEDED(hr), "Failed to create pixel shader, hr %#x.\n", hr);
+
+    /* test starting values */
+    ps_cb = create_buffer(device, D3D11_BIND_CONSTANT_BUFFER, sizeof(cutoff), cutoff);
+
+    ID3D11DeviceContext1_PSSetConstantBuffers1(context1, 0, 1, &ps_cb, offset, size);
+
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, &offset_result, &size_result);
+    ok(offset_result == 16 && size_result == 16, "Got unexpected offset and size, %u %u.\n", offset_result, size_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+    ID3D11DeviceContext_PSSetShader(context, ps, NULL, 0);
+
+    ID3D11DeviceContext_ClearRenderTargetView(context, test_context.backbuffer_rtv, red);
+
+    draw_quad(&test_context);
+
+    color = get_texture_color(test_context.backbuffer, 319, 239);
+    ok(compare_color(color, 0xff000000, 1), "Got unexpected color 0x%08x.\n", color);
+    color = get_texture_color(test_context.backbuffer, 320, 239);
+    ok(compare_color(color, 0xff00ff00, 1), "Got unexpected color 0x%08x.\n", color);
+    color = get_texture_color(test_context.backbuffer, 319, 240);
+    ok(compare_color(color, 0xffff0000, 1), "Got unexpected color 0x%08x.\n", color);
+    color = get_texture_color(test_context.backbuffer, 320, 240);
+    ok(compare_color(color, 0xffffff00, 1), "Got unexpected color 0x%08x.\n", color);
+
+    ID3D11Buffer_Release(ps_cb);
+
+    /* new offset */
+    offset[0] = 32;
+    ps_cb = create_buffer(device, D3D11_BIND_CONSTANT_BUFFER, sizeof(cutoff), cutoff);
+    ID3D11DeviceContext1_PSSetConstantBuffers1(context1, 0, 1, &ps_cb, offset, size);
+
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, &offset_result, &size_result);
+    ok(offset_result == 32 && size_result == 16, "Got unexpected offset and size, %u %u.\n", offset_result, size_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+
+    draw_quad(&test_context);
+
+    color = get_texture_color(test_context.backbuffer, 14, 14);
+    ok(compare_color(color, 0xff000000, 1), "Got unexpected color 0x%08x.\n", color);
+    color = get_texture_color(test_context.backbuffer, 18, 14);
+    ok(compare_color(color, 0xff00ff00, 1), "Got unexpected color 0x%08x.\n", color);
+    color = get_texture_color(test_context.backbuffer, 14, 18);
+    ok(compare_color(color, 0xffff0000, 1), "Got unexpected color 0x%08x.\n", color);
+    color = get_texture_color(test_context.backbuffer, 18, 18);
+    ok(compare_color(color, 0xffffff00, 1), "Got unexpected color 0x%08x.\n", color);
+
+    ID3D11Buffer_Release(ps_cb);
+
+    /* reusing buffer from now on, change offset */
+    offset[0] = 0;
+    ps_cb = create_buffer(device, D3D11_BIND_CONSTANT_BUFFER, sizeof(cutoff), cutoff);
+    ID3D11DeviceContext1_PSSetConstantBuffers1(context1, 0, 1, &ps_cb, offset, size);
+
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, &offset_result, &size_result);
+    ok(offset_result == 0 && size_result == 16, "Got unexpected offset and size, %u %u.\n", offset_result, size_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+
+    draw_quad(&test_context);
+
+    color = get_texture_color(test_context.backbuffer, 14, 14);
+    ok(compare_color(color, 0xffffff00, 1), "Got unexpected color 0x%08x.\n", color);
+
+    /* change offset */
+    offset[0] = 16;
+    ID3D11DeviceContext1_PSSetConstantBuffers1(context1, 0, 1, &ps_cb, offset, size);
+
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, &offset_result, &size_result);
+    ok(offset_result == 16 && size_result == 16, "Got unexpected offset and size, %u %u.\n", offset_result, size_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+
+    draw_quad(&test_context);
+
+    color = get_texture_color(test_context.backbuffer, 320, 239);
+    ok(compare_color(color, 0xff00ff00, 1), "Got unexpected color 0x%08x.\n", color);
+    color = get_texture_color(test_context.backbuffer, 319, 240);
+    ok(compare_color(color, 0xffff0000, 1), "Got unexpected color 0x%08x.\n", color);
+
+    /* NULL offset and size */
+    ID3D11DeviceContext1_PSSetConstantBuffers1(context1, 0, 1, &ps_cb, NULL, NULL);
+
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, &offset_result, &size_result);
+    todo_wine ok(offset_result == 0 && size_result == 4096, "Got unexpected offset and size, %u %u.\n", offset_result, size_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+
+    draw_quad(&test_context);
+
+    color = get_texture_color(test_context.backbuffer, 14, 14);
+    ok(compare_color(color, 0xffffff00, 1), "Got unexpected color 0x%08x.\n", color);
+
+    /* set offset again */
+    offset[0] = 16;
+    ID3D11DeviceContext1_PSSetConstantBuffers1(context1, 0, 1, &ps_cb, offset, size);
+
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, &offset_result, &size_result);
+    ok(offset_result == 16 && size_result == 16, "Got unexpected offset and size, %u %u.\n", offset_result, size_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+
+    draw_quad(&test_context);
+
+    color = get_texture_color(test_context.backbuffer, 320, 239);
+    ok(compare_color(color, 0xff00ff00, 1), "Got unexpected color 0x%08x.\n", color);
+
+    /* bad offset value */
+    offset[0] = 17;
+    ID3D11DeviceContext1_PSSetConstantBuffers1(context1, 0, 1, &ps_cb, offset, size);
+
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, &offset_result, &size_result);
+    todo_wine ok(offset_result == 16 && size_result == 16, "Got unexpected offset and size, %u %u.\n", offset_result, size_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+
+    draw_quad(&test_context);
+
+    color = get_texture_color(test_context.backbuffer, 320, 239);
+    ok(compare_color(color, 0xff00ff00, 1), "Got unexpected color 0x%08x.\n", color);
+    color = get_texture_color(test_context.backbuffer, 319, 240);
+    ok(compare_color(color, 0xffff0000, 1), "Got unexpected color 0x%08x.\n", color);
+
+    /* bad size value */
+    offset[0] = 16;
+    size[0] = 17;
+    ID3D11DeviceContext1_PSSetConstantBuffers1(context1, 0, 1, &ps_cb, offset, size);
+
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, &offset_result, &size_result);
+    todo_wine ok(offset_result == 16 && size_result == 16, "Got unexpected offset and size, %u %u.\n", offset_result, size_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+
+    draw_quad(&test_context);
+
+    color = get_texture_color(test_context.backbuffer, 320, 239);
+    ok(compare_color(color, 0xff00ff00, 1), "Got unexpected color 0x%08x.\n", color);
+    color = get_texture_color(test_context.backbuffer, 319, 240);
+    ok(compare_color(color, 0xffff0000, 1), "Got unexpected color 0x%08x.\n", color);
+
+    /* size bigger than buffer */
+    offset[0] = 16;
+    size[0] = 128;
+    ID3D11DeviceContext1_PSSetConstantBuffers1(context1, 0, 1, &ps_cb, offset, size);
+
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, &offset_result, &size_result);
+    ok(offset_result == 16 && size_result == 128, "Got unexpected offset and size, %u %u.\n", offset_result, size_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+
+    draw_quad(&test_context);
+
+    color = get_texture_color(test_context.backbuffer, 320, 239);
+    ok(compare_color(color, 0xff00ff00, 1), "Got unexpected color 0x%08x.\n", color);
+
+    /* just get some of the optional arguments */
+    offset_result = 0;
+    ps_cb_result = NULL;
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, &offset_result, NULL);
+    ok(offset_result == 16, "Got unexpected offset, %u.\n", offset_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+
+    size_result = 0;
+    ps_cb_result = NULL;
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, NULL, &size_result);
+    ok(size_result == 128, "Got unexpected size, %u.\n", size_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+
+    /* CRASH on this test */
+    /*offset_result = 0;
+    size_result = 0;
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, NULL, &offset_result, &size_result);
+    ok(offset_result == 16 && size_result == 128, "Got unexpected offset and size, %u %u.\n", offset_result, size_result);*/
+
+    /* dont send buffer argument */
+    /* CRASH on this test */
+    /*offset[0] = 32;
+    size[0] = 16;
+    ID3D11DeviceContext1_PSSetConstantBuffers1(context1, 0, 1, NULL, offset, size);
+
+    ps_cb_result = NULL;
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, &offset_result, &size_result);
+    ok(offset_result == 32 && size_result == 16, "Got unexpected offset and size, %u %u.\n", offset_result, size_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+
+    draw_quad(&test_context);
+
+    color = get_texture_color(test_context.backbuffer, 14, 14);
+    ok(compare_color(color, 0xff000000, 1), "Got unexpected color 0x%08x.\n", color);
+    color = get_texture_color(test_context.backbuffer, 18, 14);
+    ok(compare_color(color, 0xff00ff00, 1), "Got unexpected color 0x%08x.\n", color);*/
+
+    /* size 0 */
+    offset[0] = 32;
+    size[0] = 0;
+
+    ID3D11DeviceContext1_PSSetConstantBuffers1(context1, 0, 1, &ps_cb, offset, size);
+
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, &offset_result, &size_result);
+    ok(offset_result == 32 && size_result == 0, "Got unexpected offset and size, %u %u.\n", offset_result, size_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+
+    draw_quad(&test_context);
+
+    color = get_texture_color(test_context.backbuffer, 14, 14);
+    ok(compare_color(color, 0xffffff00, 1), "Got unexpected color 0x%08x.\n", color);
+
+    /* size bigger than max */
+    offset[0] = 16;
+    size[0] = 4112;
+    ID3D11DeviceContext1_PSSetConstantBuffers1(context1, 0, 1, &ps_cb, offset, size);
+
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, &offset_result, &size_result);
+    ok(offset_result == 32 && size_result == 0, "Got unexpected offset and size, %u %u.\n", offset_result, size_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+
+    draw_quad(&test_context);
+
+    color = get_texture_color(test_context.backbuffer, 320, 239);
+    ok(compare_color(color, 0xffffff00, 1), "Got unexpected color 0x%08x.\n", color);
+
+    /* max size */
+    offset[0] = 16;
+    size[0] = 4096;
+    ID3D11DeviceContext1_PSSetConstantBuffers1(context1, 0, 1, &ps_cb, offset, size);
+
+    ID3D11DeviceContext1_PSGetConstantBuffers1(context1, 0, 1, &ps_cb_result, &offset_result, &size_result);
+    ok(offset_result == 16 && size_result == 4096, "Got unexpected offset and size, %u %u.\n", offset_result, size_result);
+    if (ps_cb_result)
+        ID3D11Buffer_Release(ps_cb_result);
+
+    draw_quad(&test_context);
+
+    color = get_texture_color(test_context.backbuffer, 320, 239);
+    ok(compare_color(color, 0xff00ff00, 1), "Got unexpected color 0x%08x.\n", color);
+
+    /* clean up */
+    ID3D11Buffer_Release(ps_cb);
+    ID3D11DeviceContext1_Release(context1);
+    ID3D11PixelShader_Release(ps);
+    release_test_context(&test_context);
+}
+
+
 static void test_update_subresource(void)
 {
     struct d3d11_test_context test_context;
@@ -27428,6 +27749,7 @@ START_TEST(d3d11)
     run_for_each_feature_level(test_device_interfaces);
     test_get_immediate_context();
     test_create_texture1d();
+    test_buffer_offset();
     test_texture1d_interfaces();
     test_create_texture2d();
     test_texture2d_interfaces();
-- 
2.14.1

